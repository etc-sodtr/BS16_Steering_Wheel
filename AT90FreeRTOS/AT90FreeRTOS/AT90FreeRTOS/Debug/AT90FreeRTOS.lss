
AT90FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  00000d26  00000dba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d26  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000646  0080010c  0080010c  00000dc6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000dc6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000df8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000218  00000000  00000000  00000e34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002f1b  00000000  00000000  0000104c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011df  00000000  00000000  00003f67  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001782  00000000  00000000  00005146  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000610  00000000  00000000  000068c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001099  00000000  00000000  00006ed8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000225e  00000000  00000000  00007f71  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  0000a1cf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
   4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
   8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
   c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  30:	0c 94 b3 02 	jmp	0x566	; 0x566 <__vector_12>
  34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  90:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d8 e0       	ldi	r29, 0x08	; 8
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	11 e0       	ldi	r17, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	e6 e2       	ldi	r30, 0x26	; 38
  a8:	fd e0       	ldi	r31, 0x0D	; 13
  aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
  ac:	05 90       	lpm	r0, Z+
  ae:	0d 92       	st	X+, r0
  b0:	ac 30       	cpi	r26, 0x0C	; 12
  b2:	b1 07       	cpc	r27, r17
  b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
  b6:	27 e0       	ldi	r18, 0x07	; 7
  b8:	ac e0       	ldi	r26, 0x0C	; 12
  ba:	b1 e0       	ldi	r27, 0x01	; 1
  bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
  be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
  c0:	a2 35       	cpi	r26, 0x52	; 82
  c2:	b2 07       	cpc	r27, r18
  c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
  c6:	0e 94 3d 01 	call	0x27a	; 0x27a <main>
  ca:	0c 94 91 06 	jmp	0xd22	; 0xd22 <_exit>

000000ce <__bad_interrupt>:
  ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  d2:	cf 93       	push	r28
  d4:	df 93       	push	r29
  d6:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
  d8:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
  dc:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <__data_end>
  e0:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <__data_end+0x1>
  e4:	89 2b       	or	r24, r25
  e6:	31 f4       	brne	.+12     	; 0xf4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  e8:	81 e1       	ldi	r24, 0x11	; 17
  ea:	91 e0       	ldi	r25, 0x01	; 1
  ec:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <__data_end+0x1>
  f0:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  f4:	20 91 0e 01 	lds	r18, 0x010E	; 0x80010e <xNextFreeByte>
  f8:	30 91 0f 01 	lds	r19, 0x010F	; 0x80010f <xNextFreeByte+0x1>
  fc:	ce 01       	movw	r24, r28
  fe:	82 0f       	add	r24, r18
 100:	93 1f       	adc	r25, r19
 102:	8b 3d       	cpi	r24, 0xDB	; 219
 104:	45 e0       	ldi	r20, 0x05	; 5
 106:	94 07       	cpc	r25, r20
 108:	70 f4       	brcc	.+28     	; 0x126 <pvPortMalloc+0x54>
 10a:	28 17       	cp	r18, r24
 10c:	39 07       	cpc	r19, r25
 10e:	70 f4       	brcc	.+28     	; 0x12c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 110:	c0 91 0c 01 	lds	r28, 0x010C	; 0x80010c <__data_end>
 114:	d0 91 0d 01 	lds	r29, 0x010D	; 0x80010d <__data_end+0x1>
 118:	c2 0f       	add	r28, r18
 11a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 11c:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <xNextFreeByte+0x1>
 120:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <xNextFreeByte>
 124:	05 c0       	rjmp	.+10     	; 0x130 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 126:	c0 e0       	ldi	r28, 0x00	; 0
 128:	d0 e0       	ldi	r29, 0x00	; 0
 12a:	02 c0       	rjmp	.+4      	; 0x130 <pvPortMalloc+0x5e>
 12c:	c0 e0       	ldi	r28, 0x00	; 0
 12e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 130:	0e 94 2f 05 	call	0xa5e	; 0xa5e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 134:	ce 01       	movw	r24, r28
 136:	df 91       	pop	r29
 138:	cf 91       	pop	r28
 13a:	08 95       	ret

0000013c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 13c:	08 95       	ret

0000013e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 13e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 140:	03 96       	adiw	r24, 0x03	; 3
 142:	92 83       	std	Z+2, r25	; 0x02
 144:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 146:	2f ef       	ldi	r18, 0xFF	; 255
 148:	3f ef       	ldi	r19, 0xFF	; 255
 14a:	34 83       	std	Z+4, r19	; 0x04
 14c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 14e:	96 83       	std	Z+6, r25	; 0x06
 150:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 152:	90 87       	std	Z+8, r25	; 0x08
 154:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 156:	10 82       	st	Z, r1
 158:	08 95       	ret

0000015a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 15a:	fc 01       	movw	r30, r24
 15c:	11 86       	std	Z+9, r1	; 0x09
 15e:	10 86       	std	Z+8, r1	; 0x08
 160:	08 95       	ret

00000162 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 162:	cf 93       	push	r28
 164:	df 93       	push	r29
 166:	9c 01       	movw	r18, r24
 168:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 16a:	dc 01       	movw	r26, r24
 16c:	11 96       	adiw	r26, 0x01	; 1
 16e:	cd 91       	ld	r28, X+
 170:	dc 91       	ld	r29, X
 172:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 174:	d3 83       	std	Z+3, r29	; 0x03
 176:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 178:	8c 81       	ldd	r24, Y+4	; 0x04
 17a:	9d 81       	ldd	r25, Y+5	; 0x05
 17c:	95 83       	std	Z+5, r25	; 0x05
 17e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 180:	8c 81       	ldd	r24, Y+4	; 0x04
 182:	9d 81       	ldd	r25, Y+5	; 0x05
 184:	dc 01       	movw	r26, r24
 186:	13 96       	adiw	r26, 0x03	; 3
 188:	7c 93       	st	X, r23
 18a:	6e 93       	st	-X, r22
 18c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 18e:	7d 83       	std	Y+5, r23	; 0x05
 190:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 192:	31 87       	std	Z+9, r19	; 0x09
 194:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 196:	f9 01       	movw	r30, r18
 198:	80 81       	ld	r24, Z
 19a:	8f 5f       	subi	r24, 0xFF	; 255
 19c:	80 83       	st	Z, r24
}
 19e:	df 91       	pop	r29
 1a0:	cf 91       	pop	r28
 1a2:	08 95       	ret

000001a4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1a4:	cf 93       	push	r28
 1a6:	df 93       	push	r29
 1a8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1aa:	48 81       	ld	r20, Y
 1ac:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1ae:	4f 3f       	cpi	r20, 0xFF	; 255
 1b0:	2f ef       	ldi	r18, 0xFF	; 255
 1b2:	52 07       	cpc	r21, r18
 1b4:	21 f4       	brne	.+8      	; 0x1be <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1b6:	fc 01       	movw	r30, r24
 1b8:	a7 81       	ldd	r26, Z+7	; 0x07
 1ba:	b0 85       	ldd	r27, Z+8	; 0x08
 1bc:	0d c0       	rjmp	.+26     	; 0x1d8 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1be:	dc 01       	movw	r26, r24
 1c0:	13 96       	adiw	r26, 0x03	; 3
 1c2:	01 c0       	rjmp	.+2      	; 0x1c6 <vListInsert+0x22>
 1c4:	df 01       	movw	r26, r30
 1c6:	12 96       	adiw	r26, 0x02	; 2
 1c8:	ed 91       	ld	r30, X+
 1ca:	fc 91       	ld	r31, X
 1cc:	13 97       	sbiw	r26, 0x03	; 3
 1ce:	20 81       	ld	r18, Z
 1d0:	31 81       	ldd	r19, Z+1	; 0x01
 1d2:	42 17       	cp	r20, r18
 1d4:	53 07       	cpc	r21, r19
 1d6:	b0 f7       	brcc	.-20     	; 0x1c4 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1d8:	12 96       	adiw	r26, 0x02	; 2
 1da:	ed 91       	ld	r30, X+
 1dc:	fc 91       	ld	r31, X
 1de:	13 97       	sbiw	r26, 0x03	; 3
 1e0:	fb 83       	std	Y+3, r31	; 0x03
 1e2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1e4:	d5 83       	std	Z+5, r29	; 0x05
 1e6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1e8:	bd 83       	std	Y+5, r27	; 0x05
 1ea:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1ec:	13 96       	adiw	r26, 0x03	; 3
 1ee:	dc 93       	st	X, r29
 1f0:	ce 93       	st	-X, r28
 1f2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1f4:	99 87       	std	Y+9, r25	; 0x09
 1f6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1f8:	fc 01       	movw	r30, r24
 1fa:	20 81       	ld	r18, Z
 1fc:	2f 5f       	subi	r18, 0xFF	; 255
 1fe:	20 83       	st	Z, r18
}
 200:	df 91       	pop	r29
 202:	cf 91       	pop	r28
 204:	08 95       	ret

00000206 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 206:	cf 93       	push	r28
 208:	df 93       	push	r29
 20a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 20c:	a0 85       	ldd	r26, Z+8	; 0x08
 20e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 210:	c2 81       	ldd	r28, Z+2	; 0x02
 212:	d3 81       	ldd	r29, Z+3	; 0x03
 214:	84 81       	ldd	r24, Z+4	; 0x04
 216:	95 81       	ldd	r25, Z+5	; 0x05
 218:	9d 83       	std	Y+5, r25	; 0x05
 21a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 21c:	c4 81       	ldd	r28, Z+4	; 0x04
 21e:	d5 81       	ldd	r29, Z+5	; 0x05
 220:	82 81       	ldd	r24, Z+2	; 0x02
 222:	93 81       	ldd	r25, Z+3	; 0x03
 224:	9b 83       	std	Y+3, r25	; 0x03
 226:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 228:	11 96       	adiw	r26, 0x01	; 1
 22a:	cd 91       	ld	r28, X+
 22c:	dc 91       	ld	r29, X
 22e:	12 97       	sbiw	r26, 0x02	; 2
 230:	ce 17       	cp	r28, r30
 232:	df 07       	cpc	r29, r31
 234:	31 f4       	brne	.+12     	; 0x242 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 236:	8c 81       	ldd	r24, Y+4	; 0x04
 238:	9d 81       	ldd	r25, Y+5	; 0x05
 23a:	12 96       	adiw	r26, 0x02	; 2
 23c:	9c 93       	st	X, r25
 23e:	8e 93       	st	-X, r24
 240:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 242:	11 86       	std	Z+9, r1	; 0x09
 244:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 246:	8c 91       	ld	r24, X
 248:	81 50       	subi	r24, 0x01	; 1
 24a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 24c:	df 91       	pop	r29
 24e:	cf 91       	pop	r28
 250:	08 95       	ret

00000252 <blink>:
//Last update:2014.11.28;
//These defines are independent by other files;

#define NOP asm("nop")//OK;
void NOPS(int nopNo){while(nopNo--){NOP;}}
 252:	cf 93       	push	r28
 254:	df 93       	push	r29
 256:	00 d0       	rcall	.+0      	; 0x258 <blink+0x6>
 258:	cd b7       	in	r28, 0x3d	; 61
 25a:	de b7       	in	r29, 0x3e	; 62
 25c:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <xTaskGetTickCount>
 260:	9a 83       	std	Y+2, r25	; 0x02
 262:	89 83       	std	Y+1, r24	; 0x01
 264:	11 e0       	ldi	r17, 0x01	; 1
 266:	64 ef       	ldi	r22, 0xF4	; 244
 268:	71 e0       	ldi	r23, 0x01	; 1
 26a:	ce 01       	movw	r24, r28
 26c:	01 96       	adiw	r24, 0x01	; 1
 26e:	0e 94 ae 05 	call	0xb5c	; 0xb5c <vTaskDelayUntil>
 272:	84 b3       	in	r24, 0x14	; 20
 274:	81 27       	eor	r24, r17
 276:	84 bb       	out	0x14, r24	; 20
 278:	f6 cf       	rjmp	.-20     	; 0x266 <blink+0x14>

0000027a <main>:


/*-----------------------------------------------------------*/

int main( void )
{
 27a:	ef 92       	push	r14
 27c:	ff 92       	push	r15
 27e:	0f 93       	push	r16
	//CLKPR=0x80;
	// initialize port
	DDRG=0x01;
 280:	81 e0       	ldi	r24, 0x01	; 1
 282:	83 bb       	out	0x13, r24	; 19
	PORTG = 0x01;
 284:	84 bb       	out	0x14, r24	; 20
	
	

	// create blinking task
	xTaskCreate( blink, "Blink", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
 286:	e1 2c       	mov	r14, r1
 288:	f1 2c       	mov	r15, r1
 28a:	01 e0       	ldi	r16, 0x01	; 1
 28c:	20 e0       	ldi	r18, 0x00	; 0
 28e:	30 e0       	ldi	r19, 0x00	; 0
 290:	45 e5       	ldi	r20, 0x55	; 85
 292:	50 e0       	ldi	r21, 0x00	; 0
 294:	60 e0       	ldi	r22, 0x00	; 0
 296:	71 e0       	ldi	r23, 0x01	; 1
 298:	89 e2       	ldi	r24, 0x29	; 41
 29a:	91 e0       	ldi	r25, 0x01	; 1
 29c:	0e 94 2d 03 	call	0x65a	; 0x65a <xTaskCreate>

	// start the scheduler
	vTaskStartScheduler();
 2a0:	0e 94 3a 04 	call	0x874	; 0x874 <vTaskStartScheduler>

	return 0;
}
 2a4:	80 e0       	ldi	r24, 0x00	; 0
 2a6:	90 e0       	ldi	r25, 0x00	; 0
 2a8:	0f 91       	pop	r16
 2aa:	ff 90       	pop	r15
 2ac:	ef 90       	pop	r14
 2ae:	08 95       	ret

000002b0 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 2b0:	31 e1       	ldi	r19, 0x11	; 17
 2b2:	fc 01       	movw	r30, r24
 2b4:	30 83       	st	Z, r19
 2b6:	31 97       	sbiw	r30, 0x01	; 1
 2b8:	22 e2       	ldi	r18, 0x22	; 34
 2ba:	20 83       	st	Z, r18
 2bc:	31 97       	sbiw	r30, 0x01	; 1
 2be:	a3 e3       	ldi	r26, 0x33	; 51
 2c0:	a0 83       	st	Z, r26
 2c2:	31 97       	sbiw	r30, 0x01	; 1
 2c4:	60 83       	st	Z, r22
 2c6:	31 97       	sbiw	r30, 0x01	; 1
 2c8:	70 83       	st	Z, r23
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	10 82       	st	Z, r1
 2ce:	31 97       	sbiw	r30, 0x01	; 1
 2d0:	60 e8       	ldi	r22, 0x80	; 128
 2d2:	60 83       	st	Z, r22
 2d4:	31 97       	sbiw	r30, 0x01	; 1
 2d6:	10 82       	st	Z, r1
 2d8:	31 97       	sbiw	r30, 0x01	; 1
 2da:	62 e0       	ldi	r22, 0x02	; 2
 2dc:	60 83       	st	Z, r22
 2de:	31 97       	sbiw	r30, 0x01	; 1
 2e0:	63 e0       	ldi	r22, 0x03	; 3
 2e2:	60 83       	st	Z, r22
 2e4:	31 97       	sbiw	r30, 0x01	; 1
 2e6:	64 e0       	ldi	r22, 0x04	; 4
 2e8:	60 83       	st	Z, r22
 2ea:	31 97       	sbiw	r30, 0x01	; 1
 2ec:	65 e0       	ldi	r22, 0x05	; 5
 2ee:	60 83       	st	Z, r22
 2f0:	31 97       	sbiw	r30, 0x01	; 1
 2f2:	66 e0       	ldi	r22, 0x06	; 6
 2f4:	60 83       	st	Z, r22
 2f6:	31 97       	sbiw	r30, 0x01	; 1
 2f8:	67 e0       	ldi	r22, 0x07	; 7
 2fa:	60 83       	st	Z, r22
 2fc:	31 97       	sbiw	r30, 0x01	; 1
 2fe:	68 e0       	ldi	r22, 0x08	; 8
 300:	60 83       	st	Z, r22
 302:	31 97       	sbiw	r30, 0x01	; 1
 304:	69 e0       	ldi	r22, 0x09	; 9
 306:	60 83       	st	Z, r22
 308:	31 97       	sbiw	r30, 0x01	; 1
 30a:	60 e1       	ldi	r22, 0x10	; 16
 30c:	60 83       	st	Z, r22
 30e:	31 97       	sbiw	r30, 0x01	; 1
 310:	30 83       	st	Z, r19
 312:	31 97       	sbiw	r30, 0x01	; 1
 314:	32 e1       	ldi	r19, 0x12	; 18
 316:	30 83       	st	Z, r19
 318:	31 97       	sbiw	r30, 0x01	; 1
 31a:	33 e1       	ldi	r19, 0x13	; 19
 31c:	30 83       	st	Z, r19
 31e:	31 97       	sbiw	r30, 0x01	; 1
 320:	34 e1       	ldi	r19, 0x14	; 20
 322:	30 83       	st	Z, r19
 324:	31 97       	sbiw	r30, 0x01	; 1
 326:	35 e1       	ldi	r19, 0x15	; 21
 328:	30 83       	st	Z, r19
 32a:	31 97       	sbiw	r30, 0x01	; 1
 32c:	36 e1       	ldi	r19, 0x16	; 22
 32e:	30 83       	st	Z, r19
 330:	31 97       	sbiw	r30, 0x01	; 1
 332:	37 e1       	ldi	r19, 0x17	; 23
 334:	30 83       	st	Z, r19
 336:	31 97       	sbiw	r30, 0x01	; 1
 338:	38 e1       	ldi	r19, 0x18	; 24
 33a:	30 83       	st	Z, r19
 33c:	31 97       	sbiw	r30, 0x01	; 1
 33e:	39 e1       	ldi	r19, 0x19	; 25
 340:	30 83       	st	Z, r19
 342:	31 97       	sbiw	r30, 0x01	; 1
 344:	30 e2       	ldi	r19, 0x20	; 32
 346:	30 83       	st	Z, r19
 348:	31 97       	sbiw	r30, 0x01	; 1
 34a:	31 e2       	ldi	r19, 0x21	; 33
 34c:	30 83       	st	Z, r19
 34e:	31 97       	sbiw	r30, 0x01	; 1
 350:	20 83       	st	Z, r18
 352:	31 97       	sbiw	r30, 0x01	; 1
 354:	23 e2       	ldi	r18, 0x23	; 35
 356:	20 83       	st	Z, r18
 358:	31 97       	sbiw	r30, 0x01	; 1
 35a:	40 83       	st	Z, r20
 35c:	31 97       	sbiw	r30, 0x01	; 1
 35e:	50 83       	st	Z, r21
 360:	31 97       	sbiw	r30, 0x01	; 1
 362:	26 e2       	ldi	r18, 0x26	; 38
 364:	20 83       	st	Z, r18
 366:	31 97       	sbiw	r30, 0x01	; 1
 368:	27 e2       	ldi	r18, 0x27	; 39
 36a:	20 83       	st	Z, r18
 36c:	31 97       	sbiw	r30, 0x01	; 1
 36e:	28 e2       	ldi	r18, 0x28	; 40
 370:	20 83       	st	Z, r18
 372:	31 97       	sbiw	r30, 0x01	; 1
 374:	29 e2       	ldi	r18, 0x29	; 41
 376:	20 83       	st	Z, r18
 378:	31 97       	sbiw	r30, 0x01	; 1
 37a:	20 e3       	ldi	r18, 0x30	; 48
 37c:	20 83       	st	Z, r18
 37e:	31 97       	sbiw	r30, 0x01	; 1
 380:	21 e3       	ldi	r18, 0x31	; 49
 382:	20 83       	st	Z, r18
 384:	86 97       	sbiw	r24, 0x26	; 38
 386:	08 95       	ret

00000388 <xPortStartScheduler>:
 388:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 38c:	89 ef       	ldi	r24, 0xF9	; 249
 38e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 392:	8b e0       	ldi	r24, 0x0B	; 11
 394:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 398:	ef e6       	ldi	r30, 0x6F	; 111
 39a:	f0 e0       	ldi	r31, 0x00	; 0
 39c:	80 81       	ld	r24, Z
 39e:	82 e0       	ldi	r24, 0x02	; 2
 3a0:	80 83       	st	Z, r24
 3a2:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 3a6:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 3aa:	cd 91       	ld	r28, X+
 3ac:	cd bf       	out	0x3d, r28	; 61
 3ae:	dd 91       	ld	r29, X+
 3b0:	de bf       	out	0x3e, r29	; 62
 3b2:	ff 91       	pop	r31
 3b4:	ef 91       	pop	r30
 3b6:	df 91       	pop	r29
 3b8:	cf 91       	pop	r28
 3ba:	bf 91       	pop	r27
 3bc:	af 91       	pop	r26
 3be:	9f 91       	pop	r25
 3c0:	8f 91       	pop	r24
 3c2:	7f 91       	pop	r23
 3c4:	6f 91       	pop	r22
 3c6:	5f 91       	pop	r21
 3c8:	4f 91       	pop	r20
 3ca:	3f 91       	pop	r19
 3cc:	2f 91       	pop	r18
 3ce:	1f 91       	pop	r17
 3d0:	0f 91       	pop	r16
 3d2:	ff 90       	pop	r15
 3d4:	ef 90       	pop	r14
 3d6:	df 90       	pop	r13
 3d8:	cf 90       	pop	r12
 3da:	bf 90       	pop	r11
 3dc:	af 90       	pop	r10
 3de:	9f 90       	pop	r9
 3e0:	8f 90       	pop	r8
 3e2:	7f 90       	pop	r7
 3e4:	6f 90       	pop	r6
 3e6:	5f 90       	pop	r5
 3e8:	4f 90       	pop	r4
 3ea:	3f 90       	pop	r3
 3ec:	2f 90       	pop	r2
 3ee:	1f 90       	pop	r1
 3f0:	0f 90       	pop	r0
 3f2:	0f be       	out	0x3f, r0	; 63
 3f4:	0f 90       	pop	r0
 3f6:	08 95       	ret
 3f8:	81 e0       	ldi	r24, 0x01	; 1
 3fa:	08 95       	ret

000003fc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3fc:	0f 92       	push	r0
 3fe:	0f b6       	in	r0, 0x3f	; 63
 400:	f8 94       	cli
 402:	0f 92       	push	r0
 404:	1f 92       	push	r1
 406:	11 24       	eor	r1, r1
 408:	2f 92       	push	r2
 40a:	3f 92       	push	r3
 40c:	4f 92       	push	r4
 40e:	5f 92       	push	r5
 410:	6f 92       	push	r6
 412:	7f 92       	push	r7
 414:	8f 92       	push	r8
 416:	9f 92       	push	r9
 418:	af 92       	push	r10
 41a:	bf 92       	push	r11
 41c:	cf 92       	push	r12
 41e:	df 92       	push	r13
 420:	ef 92       	push	r14
 422:	ff 92       	push	r15
 424:	0f 93       	push	r16
 426:	1f 93       	push	r17
 428:	2f 93       	push	r18
 42a:	3f 93       	push	r19
 42c:	4f 93       	push	r20
 42e:	5f 93       	push	r21
 430:	6f 93       	push	r22
 432:	7f 93       	push	r23
 434:	8f 93       	push	r24
 436:	9f 93       	push	r25
 438:	af 93       	push	r26
 43a:	bf 93       	push	r27
 43c:	cf 93       	push	r28
 43e:	df 93       	push	r29
 440:	ef 93       	push	r30
 442:	ff 93       	push	r31
 444:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 448:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 44c:	0d b6       	in	r0, 0x3d	; 61
 44e:	0d 92       	st	X+, r0
 450:	0e b6       	in	r0, 0x3e	; 62
 452:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 454:	0e 94 2b 06 	call	0xc56	; 0xc56 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 458:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 45c:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 460:	cd 91       	ld	r28, X+
 462:	cd bf       	out	0x3d, r28	; 61
 464:	dd 91       	ld	r29, X+
 466:	de bf       	out	0x3e, r29	; 62
 468:	ff 91       	pop	r31
 46a:	ef 91       	pop	r30
 46c:	df 91       	pop	r29
 46e:	cf 91       	pop	r28
 470:	bf 91       	pop	r27
 472:	af 91       	pop	r26
 474:	9f 91       	pop	r25
 476:	8f 91       	pop	r24
 478:	7f 91       	pop	r23
 47a:	6f 91       	pop	r22
 47c:	5f 91       	pop	r21
 47e:	4f 91       	pop	r20
 480:	3f 91       	pop	r19
 482:	2f 91       	pop	r18
 484:	1f 91       	pop	r17
 486:	0f 91       	pop	r16
 488:	ff 90       	pop	r15
 48a:	ef 90       	pop	r14
 48c:	df 90       	pop	r13
 48e:	cf 90       	pop	r12
 490:	bf 90       	pop	r11
 492:	af 90       	pop	r10
 494:	9f 90       	pop	r9
 496:	8f 90       	pop	r8
 498:	7f 90       	pop	r7
 49a:	6f 90       	pop	r6
 49c:	5f 90       	pop	r5
 49e:	4f 90       	pop	r4
 4a0:	3f 90       	pop	r3
 4a2:	2f 90       	pop	r2
 4a4:	1f 90       	pop	r1
 4a6:	0f 90       	pop	r0
 4a8:	0f be       	out	0x3f, r0	; 63
 4aa:	0f 90       	pop	r0

	asm volatile ( "ret" );
 4ac:	08 95       	ret

000004ae <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 4ae:	0f 92       	push	r0
 4b0:	0f b6       	in	r0, 0x3f	; 63
 4b2:	f8 94       	cli
 4b4:	0f 92       	push	r0
 4b6:	1f 92       	push	r1
 4b8:	11 24       	eor	r1, r1
 4ba:	2f 92       	push	r2
 4bc:	3f 92       	push	r3
 4be:	4f 92       	push	r4
 4c0:	5f 92       	push	r5
 4c2:	6f 92       	push	r6
 4c4:	7f 92       	push	r7
 4c6:	8f 92       	push	r8
 4c8:	9f 92       	push	r9
 4ca:	af 92       	push	r10
 4cc:	bf 92       	push	r11
 4ce:	cf 92       	push	r12
 4d0:	df 92       	push	r13
 4d2:	ef 92       	push	r14
 4d4:	ff 92       	push	r15
 4d6:	0f 93       	push	r16
 4d8:	1f 93       	push	r17
 4da:	2f 93       	push	r18
 4dc:	3f 93       	push	r19
 4de:	4f 93       	push	r20
 4e0:	5f 93       	push	r21
 4e2:	6f 93       	push	r22
 4e4:	7f 93       	push	r23
 4e6:	8f 93       	push	r24
 4e8:	9f 93       	push	r25
 4ea:	af 93       	push	r26
 4ec:	bf 93       	push	r27
 4ee:	cf 93       	push	r28
 4f0:	df 93       	push	r29
 4f2:	ef 93       	push	r30
 4f4:	ff 93       	push	r31
 4f6:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 4fa:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 4fe:	0d b6       	in	r0, 0x3d	; 61
 500:	0d 92       	st	X+, r0
 502:	0e b6       	in	r0, 0x3e	; 62
 504:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 506:	0e 94 74 04 	call	0x8e8	; 0x8e8 <xTaskIncrementTick>
 50a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 50c:	0e 94 2b 06 	call	0xc56	; 0xc56 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 510:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
 514:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 518:	cd 91       	ld	r28, X+
 51a:	cd bf       	out	0x3d, r28	; 61
 51c:	dd 91       	ld	r29, X+
 51e:	de bf       	out	0x3e, r29	; 62
 520:	ff 91       	pop	r31
 522:	ef 91       	pop	r30
 524:	df 91       	pop	r29
 526:	cf 91       	pop	r28
 528:	bf 91       	pop	r27
 52a:	af 91       	pop	r26
 52c:	9f 91       	pop	r25
 52e:	8f 91       	pop	r24
 530:	7f 91       	pop	r23
 532:	6f 91       	pop	r22
 534:	5f 91       	pop	r21
 536:	4f 91       	pop	r20
 538:	3f 91       	pop	r19
 53a:	2f 91       	pop	r18
 53c:	1f 91       	pop	r17
 53e:	0f 91       	pop	r16
 540:	ff 90       	pop	r15
 542:	ef 90       	pop	r14
 544:	df 90       	pop	r13
 546:	cf 90       	pop	r12
 548:	bf 90       	pop	r11
 54a:	af 90       	pop	r10
 54c:	9f 90       	pop	r9
 54e:	8f 90       	pop	r8
 550:	7f 90       	pop	r7
 552:	6f 90       	pop	r6
 554:	5f 90       	pop	r5
 556:	4f 90       	pop	r4
 558:	3f 90       	pop	r3
 55a:	2f 90       	pop	r2
 55c:	1f 90       	pop	r1
 55e:	0f 90       	pop	r0
 560:	0f be       	out	0x3f, r0	; 63
 562:	0f 90       	pop	r0

	asm volatile ( "ret" );
 564:	08 95       	ret

00000566 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 566:	0e 94 57 02 	call	0x4ae	; 0x4ae <vPortYieldFromTick>
		asm volatile ( "reti" );
 56a:	18 95       	reti

0000056c <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 56c:	e0 91 18 07 	lds	r30, 0x0718	; 0x800718 <pxDelayedTaskList>
 570:	f0 91 19 07 	lds	r31, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 574:	80 81       	ld	r24, Z
 576:	81 11       	cpse	r24, r1
 578:	07 c0       	rjmp	.+14     	; 0x588 <prvResetNextTaskUnblockTime+0x1c>
 57a:	8f ef       	ldi	r24, 0xFF	; 255
 57c:	9f ef       	ldi	r25, 0xFF	; 255
 57e:	90 93 f0 06 	sts	0x06F0, r25	; 0x8006f0 <xNextTaskUnblockTime+0x1>
 582:	80 93 ef 06 	sts	0x06EF, r24	; 0x8006ef <xNextTaskUnblockTime>
 586:	08 95       	ret
 588:	e0 91 18 07 	lds	r30, 0x0718	; 0x800718 <pxDelayedTaskList>
 58c:	f0 91 19 07 	lds	r31, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 590:	05 80       	ldd	r0, Z+5	; 0x05
 592:	f6 81       	ldd	r31, Z+6	; 0x06
 594:	e0 2d       	mov	r30, r0
 596:	06 80       	ldd	r0, Z+6	; 0x06
 598:	f7 81       	ldd	r31, Z+7	; 0x07
 59a:	e0 2d       	mov	r30, r0
 59c:	82 81       	ldd	r24, Z+2	; 0x02
 59e:	93 81       	ldd	r25, Z+3	; 0x03
 5a0:	90 93 f0 06 	sts	0x06F0, r25	; 0x8006f0 <xNextTaskUnblockTime+0x1>
 5a4:	80 93 ef 06 	sts	0x06EF, r24	; 0x8006ef <xNextTaskUnblockTime>
 5a8:	08 95       	ret

000005aa <prvAddCurrentTaskToDelayedList>:
 5aa:	ff 92       	push	r15
 5ac:	0f 93       	push	r16
 5ae:	1f 93       	push	r17
 5b0:	cf 93       	push	r28
 5b2:	df 93       	push	r29
 5b4:	ec 01       	movw	r28, r24
 5b6:	f6 2e       	mov	r15, r22
 5b8:	00 91 f7 06 	lds	r16, 0x06F7	; 0x8006f7 <xTickCount>
 5bc:	10 91 f8 06 	lds	r17, 0x06F8	; 0x8006f8 <xTickCount+0x1>
 5c0:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
 5c4:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 5c8:	02 96       	adiw	r24, 0x02	; 2
 5ca:	0e 94 03 01 	call	0x206	; 0x206 <uxListRemove>
 5ce:	cf 3f       	cpi	r28, 0xFF	; 255
 5d0:	8f ef       	ldi	r24, 0xFF	; 255
 5d2:	d8 07       	cpc	r29, r24
 5d4:	69 f4       	brne	.+26     	; 0x5f0 <prvAddCurrentTaskToDelayedList+0x46>
 5d6:	ff 20       	and	r15, r15
 5d8:	59 f0       	breq	.+22     	; 0x5f0 <prvAddCurrentTaskToDelayedList+0x46>
 5da:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
 5de:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 5e2:	6e 5f       	subi	r22, 0xFE	; 254
 5e4:	7f 4f       	sbci	r23, 0xFF	; 255
 5e6:	8a ef       	ldi	r24, 0xFA	; 250
 5e8:	96 e0       	ldi	r25, 0x06	; 6
 5ea:	0e 94 b1 00 	call	0x162	; 0x162 <vListInsertEnd>
 5ee:	2f c0       	rjmp	.+94     	; 0x64e <prvAddCurrentTaskToDelayedList+0xa4>
 5f0:	c0 0f       	add	r28, r16
 5f2:	d1 1f       	adc	r29, r17
 5f4:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 5f8:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 5fc:	d3 83       	std	Z+3, r29	; 0x03
 5fe:	c2 83       	std	Z+2, r28	; 0x02
 600:	c0 17       	cp	r28, r16
 602:	d1 07       	cpc	r29, r17
 604:	68 f4       	brcc	.+26     	; 0x620 <prvAddCurrentTaskToDelayedList+0x76>
 606:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
 60a:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 60e:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <pxOverflowDelayedTaskList>
 612:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <pxOverflowDelayedTaskList+0x1>
 616:	6e 5f       	subi	r22, 0xFE	; 254
 618:	7f 4f       	sbci	r23, 0xFF	; 255
 61a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInsert>
 61e:	17 c0       	rjmp	.+46     	; 0x64e <prvAddCurrentTaskToDelayedList+0xa4>
 620:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
 624:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 628:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <pxDelayedTaskList>
 62c:	90 91 19 07 	lds	r25, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 630:	6e 5f       	subi	r22, 0xFE	; 254
 632:	7f 4f       	sbci	r23, 0xFF	; 255
 634:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInsert>
 638:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <xNextTaskUnblockTime>
 63c:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <xNextTaskUnblockTime+0x1>
 640:	c8 17       	cp	r28, r24
 642:	d9 07       	cpc	r29, r25
 644:	20 f4       	brcc	.+8      	; 0x64e <prvAddCurrentTaskToDelayedList+0xa4>
 646:	d0 93 f0 06 	sts	0x06F0, r29	; 0x8006f0 <xNextTaskUnblockTime+0x1>
 64a:	c0 93 ef 06 	sts	0x06EF, r28	; 0x8006ef <xNextTaskUnblockTime>
 64e:	df 91       	pop	r29
 650:	cf 91       	pop	r28
 652:	1f 91       	pop	r17
 654:	0f 91       	pop	r16
 656:	ff 90       	pop	r15
 658:	08 95       	ret

0000065a <xTaskCreate>:
 65a:	4f 92       	push	r4
 65c:	5f 92       	push	r5
 65e:	6f 92       	push	r6
 660:	7f 92       	push	r7
 662:	8f 92       	push	r8
 664:	9f 92       	push	r9
 666:	af 92       	push	r10
 668:	bf 92       	push	r11
 66a:	cf 92       	push	r12
 66c:	df 92       	push	r13
 66e:	ef 92       	push	r14
 670:	ff 92       	push	r15
 672:	0f 93       	push	r16
 674:	cf 93       	push	r28
 676:	df 93       	push	r29
 678:	4c 01       	movw	r8, r24
 67a:	6b 01       	movw	r12, r22
 67c:	5a 01       	movw	r10, r20
 67e:	29 01       	movw	r4, r18
 680:	ca 01       	movw	r24, r20
 682:	0e 94 69 00 	call	0xd2	; 0xd2 <pvPortMalloc>
 686:	3c 01       	movw	r6, r24
 688:	89 2b       	or	r24, r25
 68a:	09 f4       	brne	.+2      	; 0x68e <xTaskCreate+0x34>
 68c:	e2 c0       	rjmp	.+452    	; 0x852 <xTaskCreate+0x1f8>
 68e:	86 e2       	ldi	r24, 0x26	; 38
 690:	90 e0       	ldi	r25, 0x00	; 0
 692:	0e 94 69 00 	call	0xd2	; 0xd2 <pvPortMalloc>
 696:	ec 01       	movw	r28, r24
 698:	89 2b       	or	r24, r25
 69a:	71 f0       	breq	.+28     	; 0x6b8 <xTaskCreate+0x5e>
 69c:	78 8e       	std	Y+24, r7	; 0x18
 69e:	6f 8a       	std	Y+23, r6	; 0x17
 6a0:	81 e0       	ldi	r24, 0x01	; 1
 6a2:	a8 1a       	sub	r10, r24
 6a4:	b1 08       	sbc	r11, r1
 6a6:	6a 0c       	add	r6, r10
 6a8:	7b 1c       	adc	r7, r11
 6aa:	d6 01       	movw	r26, r12
 6ac:	8c 91       	ld	r24, X
 6ae:	89 8f       	std	Y+25, r24	; 0x19
 6b0:	8c 91       	ld	r24, X
 6b2:	81 11       	cpse	r24, r1
 6b4:	05 c0       	rjmp	.+10     	; 0x6c0 <xTaskCreate+0x66>
 6b6:	18 c0       	rjmp	.+48     	; 0x6e8 <xTaskCreate+0x8e>
 6b8:	c3 01       	movw	r24, r6
 6ba:	0e 94 9e 00 	call	0x13c	; 0x13c <vPortFree>
 6be:	c9 c0       	rjmp	.+402    	; 0x852 <xTaskCreate+0x1f8>
 6c0:	ae 01       	movw	r20, r28
 6c2:	46 5e       	subi	r20, 0xE6	; 230
 6c4:	5f 4f       	sbci	r21, 0xFF	; 255
 6c6:	f6 01       	movw	r30, r12
 6c8:	31 96       	adiw	r30, 0x01	; 1
 6ca:	b8 e0       	ldi	r27, 0x08	; 8
 6cc:	cb 0e       	add	r12, r27
 6ce:	d1 1c       	adc	r13, r1
 6d0:	cf 01       	movw	r24, r30
 6d2:	21 91       	ld	r18, Z+
 6d4:	da 01       	movw	r26, r20
 6d6:	2d 93       	st	X+, r18
 6d8:	ad 01       	movw	r20, r26
 6da:	dc 01       	movw	r26, r24
 6dc:	8c 91       	ld	r24, X
 6de:	88 23       	and	r24, r24
 6e0:	19 f0       	breq	.+6      	; 0x6e8 <xTaskCreate+0x8e>
 6e2:	ec 15       	cp	r30, r12
 6e4:	fd 05       	cpc	r31, r13
 6e6:	a1 f7       	brne	.-24     	; 0x6d0 <xTaskCreate+0x76>
 6e8:	18 a2       	std	Y+32, r1	; 0x20
 6ea:	04 30       	cpi	r16, 0x04	; 4
 6ec:	08 f0       	brcs	.+2      	; 0x6f0 <xTaskCreate+0x96>
 6ee:	03 e0       	ldi	r16, 0x03	; 3
 6f0:	0e 8b       	std	Y+22, r16	; 0x16
 6f2:	6e 01       	movw	r12, r28
 6f4:	b2 e0       	ldi	r27, 0x02	; 2
 6f6:	cb 0e       	add	r12, r27
 6f8:	d1 1c       	adc	r13, r1
 6fa:	c6 01       	movw	r24, r12
 6fc:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialiseItem>
 700:	ce 01       	movw	r24, r28
 702:	0c 96       	adiw	r24, 0x0c	; 12
 704:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialiseItem>
 708:	d9 87       	std	Y+9, r29	; 0x09
 70a:	c8 87       	std	Y+8, r28	; 0x08
 70c:	84 e0       	ldi	r24, 0x04	; 4
 70e:	90 e0       	ldi	r25, 0x00	; 0
 710:	80 1b       	sub	r24, r16
 712:	91 09       	sbc	r25, r1
 714:	9d 87       	std	Y+13, r25	; 0x0d
 716:	8c 87       	std	Y+12, r24	; 0x0c
 718:	db 8b       	std	Y+19, r29	; 0x13
 71a:	ca 8b       	std	Y+18, r28	; 0x12
 71c:	19 a2       	std	Y+33, r1	; 0x21
 71e:	1a a2       	std	Y+34, r1	; 0x22
 720:	1b a2       	std	Y+35, r1	; 0x23
 722:	1c a2       	std	Y+36, r1	; 0x24
 724:	1d a2       	std	Y+37, r1	; 0x25
 726:	a2 01       	movw	r20, r4
 728:	b4 01       	movw	r22, r8
 72a:	c3 01       	movw	r24, r6
 72c:	0e 94 58 01 	call	0x2b0	; 0x2b0 <pxPortInitialiseStack>
 730:	99 83       	std	Y+1, r25	; 0x01
 732:	88 83       	st	Y, r24
 734:	e1 14       	cp	r14, r1
 736:	f1 04       	cpc	r15, r1
 738:	19 f0       	breq	.+6      	; 0x740 <xTaskCreate+0xe6>
 73a:	f7 01       	movw	r30, r14
 73c:	d1 83       	std	Z+1, r29	; 0x01
 73e:	c0 83       	st	Z, r28
 740:	0f b6       	in	r0, 0x3f	; 63
 742:	f8 94       	cli
 744:	0f 92       	push	r0
 746:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxCurrentNumberOfTasks>
 74a:	8f 5f       	subi	r24, 0xFF	; 255
 74c:	80 93 f9 06 	sts	0x06F9, r24	; 0x8006f9 <uxCurrentNumberOfTasks>
 750:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
 754:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 758:	89 2b       	or	r24, r25
 75a:	d1 f5       	brne	.+116    	; 0x7d0 <xTaskCreate+0x176>
 75c:	d0 93 51 07 	sts	0x0751, r29	; 0x800751 <pxCurrentTCB+0x1>
 760:	c0 93 50 07 	sts	0x0750, r28	; 0x800750 <pxCurrentTCB>
 764:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxCurrentNumberOfTasks>
 768:	81 30       	cpi	r24, 0x01	; 1
 76a:	09 f0       	breq	.+2      	; 0x76e <xTaskCreate+0x114>
 76c:	41 c0       	rjmp	.+130    	; 0x7f0 <xTaskCreate+0x196>
 76e:	8c e2       	ldi	r24, 0x2C	; 44
 770:	97 e0       	ldi	r25, 0x07	; 7
 772:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 776:	85 e3       	ldi	r24, 0x35	; 53
 778:	97 e0       	ldi	r25, 0x07	; 7
 77a:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 77e:	8e e3       	ldi	r24, 0x3E	; 62
 780:	97 e0       	ldi	r25, 0x07	; 7
 782:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 786:	87 e4       	ldi	r24, 0x47	; 71
 788:	97 e0       	ldi	r25, 0x07	; 7
 78a:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 78e:	83 e2       	ldi	r24, 0x23	; 35
 790:	97 e0       	ldi	r25, 0x07	; 7
 792:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 796:	8a e1       	ldi	r24, 0x1A	; 26
 798:	97 e0       	ldi	r25, 0x07	; 7
 79a:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 79e:	8d e0       	ldi	r24, 0x0D	; 13
 7a0:	97 e0       	ldi	r25, 0x07	; 7
 7a2:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 7a6:	84 e0       	ldi	r24, 0x04	; 4
 7a8:	97 e0       	ldi	r25, 0x07	; 7
 7aa:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 7ae:	8a ef       	ldi	r24, 0xFA	; 250
 7b0:	96 e0       	ldi	r25, 0x06	; 6
 7b2:	0e 94 9f 00 	call	0x13e	; 0x13e <vListInitialise>
 7b6:	83 e2       	ldi	r24, 0x23	; 35
 7b8:	97 e0       	ldi	r25, 0x07	; 7
 7ba:	90 93 19 07 	sts	0x0719, r25	; 0x800719 <pxDelayedTaskList+0x1>
 7be:	80 93 18 07 	sts	0x0718, r24	; 0x800718 <pxDelayedTaskList>
 7c2:	8a e1       	ldi	r24, 0x1A	; 26
 7c4:	97 e0       	ldi	r25, 0x07	; 7
 7c6:	90 93 17 07 	sts	0x0717, r25	; 0x800717 <pxOverflowDelayedTaskList+0x1>
 7ca:	80 93 16 07 	sts	0x0716, r24	; 0x800716 <pxOverflowDelayedTaskList>
 7ce:	10 c0       	rjmp	.+32     	; 0x7f0 <xTaskCreate+0x196>
 7d0:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <xSchedulerRunning>
 7d4:	81 11       	cpse	r24, r1
 7d6:	0c c0       	rjmp	.+24     	; 0x7f0 <xTaskCreate+0x196>
 7d8:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 7dc:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 7e0:	96 89       	ldd	r25, Z+22	; 0x16
 7e2:	8e 89       	ldd	r24, Y+22	; 0x16
 7e4:	89 17       	cp	r24, r25
 7e6:	20 f0       	brcs	.+8      	; 0x7f0 <xTaskCreate+0x196>
 7e8:	d0 93 51 07 	sts	0x0751, r29	; 0x800751 <pxCurrentTCB+0x1>
 7ec:	c0 93 50 07 	sts	0x0750, r28	; 0x800750 <pxCurrentTCB>
 7f0:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <uxTaskNumber>
 7f4:	8f 5f       	subi	r24, 0xFF	; 255
 7f6:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <uxTaskNumber>
 7fa:	8e 89       	ldd	r24, Y+22	; 0x16
 7fc:	90 91 f6 06 	lds	r25, 0x06F6	; 0x8006f6 <uxTopReadyPriority>
 800:	98 17       	cp	r25, r24
 802:	10 f4       	brcc	.+4      	; 0x808 <xTaskCreate+0x1ae>
 804:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <uxTopReadyPriority>
 808:	90 e0       	ldi	r25, 0x00	; 0
 80a:	9c 01       	movw	r18, r24
 80c:	22 0f       	add	r18, r18
 80e:	33 1f       	adc	r19, r19
 810:	22 0f       	add	r18, r18
 812:	33 1f       	adc	r19, r19
 814:	22 0f       	add	r18, r18
 816:	33 1f       	adc	r19, r19
 818:	82 0f       	add	r24, r18
 81a:	93 1f       	adc	r25, r19
 81c:	b6 01       	movw	r22, r12
 81e:	84 5d       	subi	r24, 0xD4	; 212
 820:	98 4f       	sbci	r25, 0xF8	; 248
 822:	0e 94 b1 00 	call	0x162	; 0x162 <vListInsertEnd>
 826:	0f 90       	pop	r0
 828:	0f be       	out	0x3f, r0	; 63
 82a:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <xSchedulerRunning>
 82e:	88 23       	and	r24, r24
 830:	61 f0       	breq	.+24     	; 0x84a <xTaskCreate+0x1f0>
 832:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 836:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 83a:	96 89       	ldd	r25, Z+22	; 0x16
 83c:	8e 89       	ldd	r24, Y+22	; 0x16
 83e:	98 17       	cp	r25, r24
 840:	30 f4       	brcc	.+12     	; 0x84e <xTaskCreate+0x1f4>
 842:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortYield>
 846:	81 e0       	ldi	r24, 0x01	; 1
 848:	05 c0       	rjmp	.+10     	; 0x854 <xTaskCreate+0x1fa>
 84a:	81 e0       	ldi	r24, 0x01	; 1
 84c:	03 c0       	rjmp	.+6      	; 0x854 <xTaskCreate+0x1fa>
 84e:	81 e0       	ldi	r24, 0x01	; 1
 850:	01 c0       	rjmp	.+2      	; 0x854 <xTaskCreate+0x1fa>
 852:	8f ef       	ldi	r24, 0xFF	; 255
 854:	df 91       	pop	r29
 856:	cf 91       	pop	r28
 858:	0f 91       	pop	r16
 85a:	ff 90       	pop	r15
 85c:	ef 90       	pop	r14
 85e:	df 90       	pop	r13
 860:	cf 90       	pop	r12
 862:	bf 90       	pop	r11
 864:	af 90       	pop	r10
 866:	9f 90       	pop	r9
 868:	8f 90       	pop	r8
 86a:	7f 90       	pop	r7
 86c:	6f 90       	pop	r6
 86e:	5f 90       	pop	r5
 870:	4f 90       	pop	r4
 872:	08 95       	ret

00000874 <vTaskStartScheduler>:
 874:	ef 92       	push	r14
 876:	ff 92       	push	r15
 878:	0f 93       	push	r16
 87a:	0f 2e       	mov	r0, r31
 87c:	fd ee       	ldi	r31, 0xED	; 237
 87e:	ef 2e       	mov	r14, r31
 880:	f6 e0       	ldi	r31, 0x06	; 6
 882:	ff 2e       	mov	r15, r31
 884:	f0 2d       	mov	r31, r0
 886:	00 e0       	ldi	r16, 0x00	; 0
 888:	20 e0       	ldi	r18, 0x00	; 0
 88a:	30 e0       	ldi	r19, 0x00	; 0
 88c:	45 e5       	ldi	r20, 0x55	; 85
 88e:	50 e0       	ldi	r21, 0x00	; 0
 890:	66 e0       	ldi	r22, 0x06	; 6
 892:	71 e0       	ldi	r23, 0x01	; 1
 894:	8e ee       	ldi	r24, 0xEE	; 238
 896:	95 e0       	ldi	r25, 0x05	; 5
 898:	0e 94 2d 03 	call	0x65a	; 0x65a <xTaskCreate>
 89c:	81 30       	cpi	r24, 0x01	; 1
 89e:	81 f4       	brne	.+32     	; 0x8c0 <vTaskStartScheduler+0x4c>
 8a0:	f8 94       	cli
 8a2:	8f ef       	ldi	r24, 0xFF	; 255
 8a4:	9f ef       	ldi	r25, 0xFF	; 255
 8a6:	90 93 f0 06 	sts	0x06F0, r25	; 0x8006f0 <xNextTaskUnblockTime+0x1>
 8aa:	80 93 ef 06 	sts	0x06EF, r24	; 0x8006ef <xNextTaskUnblockTime>
 8ae:	81 e0       	ldi	r24, 0x01	; 1
 8b0:	80 93 f5 06 	sts	0x06F5, r24	; 0x8006f5 <xSchedulerRunning>
 8b4:	10 92 f8 06 	sts	0x06F8, r1	; 0x8006f8 <xTickCount+0x1>
 8b8:	10 92 f7 06 	sts	0x06F7, r1	; 0x8006f7 <xTickCount>
 8bc:	0e 94 c4 01 	call	0x388	; 0x388 <xPortStartScheduler>
 8c0:	0f 91       	pop	r16
 8c2:	ff 90       	pop	r15
 8c4:	ef 90       	pop	r14
 8c6:	08 95       	ret

000008c8 <vTaskSuspendAll>:
 8c8:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <uxSchedulerSuspended>
 8cc:	8f 5f       	subi	r24, 0xFF	; 255
 8ce:	80 93 ec 06 	sts	0x06EC, r24	; 0x8006ec <uxSchedulerSuspended>
 8d2:	08 95       	ret

000008d4 <xTaskGetTickCount>:
 8d4:	0f b6       	in	r0, 0x3f	; 63
 8d6:	f8 94       	cli
 8d8:	0f 92       	push	r0
 8da:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <xTickCount>
 8de:	90 91 f8 06 	lds	r25, 0x06F8	; 0x8006f8 <xTickCount+0x1>
 8e2:	0f 90       	pop	r0
 8e4:	0f be       	out	0x3f, r0	; 63
 8e6:	08 95       	ret

000008e8 <xTaskIncrementTick>:
 8e8:	cf 92       	push	r12
 8ea:	df 92       	push	r13
 8ec:	ef 92       	push	r14
 8ee:	ff 92       	push	r15
 8f0:	0f 93       	push	r16
 8f2:	1f 93       	push	r17
 8f4:	cf 93       	push	r28
 8f6:	df 93       	push	r29
 8f8:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <uxSchedulerSuspended>
 8fc:	81 11       	cpse	r24, r1
 8fe:	99 c0       	rjmp	.+306    	; 0xa32 <__stack+0x133>
 900:	e0 90 f7 06 	lds	r14, 0x06F7	; 0x8006f7 <xTickCount>
 904:	f0 90 f8 06 	lds	r15, 0x06F8	; 0x8006f8 <xTickCount+0x1>
 908:	8f ef       	ldi	r24, 0xFF	; 255
 90a:	e8 1a       	sub	r14, r24
 90c:	f8 0a       	sbc	r15, r24
 90e:	f0 92 f8 06 	sts	0x06F8, r15	; 0x8006f8 <xTickCount+0x1>
 912:	e0 92 f7 06 	sts	0x06F7, r14	; 0x8006f7 <xTickCount>
 916:	e1 14       	cp	r14, r1
 918:	f1 04       	cpc	r15, r1
 91a:	b9 f4       	brne	.+46     	; 0x94a <__stack+0x4b>
 91c:	80 91 18 07 	lds	r24, 0x0718	; 0x800718 <pxDelayedTaskList>
 920:	90 91 19 07 	lds	r25, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 924:	20 91 16 07 	lds	r18, 0x0716	; 0x800716 <pxOverflowDelayedTaskList>
 928:	30 91 17 07 	lds	r19, 0x0717	; 0x800717 <pxOverflowDelayedTaskList+0x1>
 92c:	30 93 19 07 	sts	0x0719, r19	; 0x800719 <pxDelayedTaskList+0x1>
 930:	20 93 18 07 	sts	0x0718, r18	; 0x800718 <pxDelayedTaskList>
 934:	90 93 17 07 	sts	0x0717, r25	; 0x800717 <pxOverflowDelayedTaskList+0x1>
 938:	80 93 16 07 	sts	0x0716, r24	; 0x800716 <pxOverflowDelayedTaskList>
 93c:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <xNumOfOverflows>
 940:	8f 5f       	subi	r24, 0xFF	; 255
 942:	80 93 f2 06 	sts	0x06F2, r24	; 0x8006f2 <xNumOfOverflows>
 946:	0e 94 b6 02 	call	0x56c	; 0x56c <prvResetNextTaskUnblockTime>
 94a:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <xNextTaskUnblockTime>
 94e:	90 91 f0 06 	lds	r25, 0x06F0	; 0x8006f0 <xNextTaskUnblockTime+0x1>
 952:	e8 16       	cp	r14, r24
 954:	f9 06       	cpc	r15, r25
 956:	10 f4       	brcc	.+4      	; 0x95c <__stack+0x5d>
 958:	d1 2c       	mov	r13, r1
 95a:	53 c0       	rjmp	.+166    	; 0xa02 <__stack+0x103>
 95c:	d1 2c       	mov	r13, r1
 95e:	cc 24       	eor	r12, r12
 960:	c3 94       	inc	r12
 962:	e0 91 18 07 	lds	r30, 0x0718	; 0x800718 <pxDelayedTaskList>
 966:	f0 91 19 07 	lds	r31, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 96a:	90 81       	ld	r25, Z
 96c:	91 11       	cpse	r25, r1
 96e:	07 c0       	rjmp	.+14     	; 0x97e <__stack+0x7f>
 970:	8f ef       	ldi	r24, 0xFF	; 255
 972:	9f ef       	ldi	r25, 0xFF	; 255
 974:	90 93 f0 06 	sts	0x06F0, r25	; 0x8006f0 <xNextTaskUnblockTime+0x1>
 978:	80 93 ef 06 	sts	0x06EF, r24	; 0x8006ef <xNextTaskUnblockTime>
 97c:	42 c0       	rjmp	.+132    	; 0xa02 <__stack+0x103>
 97e:	e0 91 18 07 	lds	r30, 0x0718	; 0x800718 <pxDelayedTaskList>
 982:	f0 91 19 07 	lds	r31, 0x0719	; 0x800719 <pxDelayedTaskList+0x1>
 986:	05 80       	ldd	r0, Z+5	; 0x05
 988:	f6 81       	ldd	r31, Z+6	; 0x06
 98a:	e0 2d       	mov	r30, r0
 98c:	c6 81       	ldd	r28, Z+6	; 0x06
 98e:	d7 81       	ldd	r29, Z+7	; 0x07
 990:	2a 81       	ldd	r18, Y+2	; 0x02
 992:	3b 81       	ldd	r19, Y+3	; 0x03
 994:	e2 16       	cp	r14, r18
 996:	f3 06       	cpc	r15, r19
 998:	28 f4       	brcc	.+10     	; 0x9a4 <__stack+0xa5>
 99a:	30 93 f0 06 	sts	0x06F0, r19	; 0x8006f0 <xNextTaskUnblockTime+0x1>
 99e:	20 93 ef 06 	sts	0x06EF, r18	; 0x8006ef <xNextTaskUnblockTime>
 9a2:	2f c0       	rjmp	.+94     	; 0xa02 <__stack+0x103>
 9a4:	8e 01       	movw	r16, r28
 9a6:	0e 5f       	subi	r16, 0xFE	; 254
 9a8:	1f 4f       	sbci	r17, 0xFF	; 255
 9aa:	c8 01       	movw	r24, r16
 9ac:	0e 94 03 01 	call	0x206	; 0x206 <uxListRemove>
 9b0:	8c 89       	ldd	r24, Y+20	; 0x14
 9b2:	9d 89       	ldd	r25, Y+21	; 0x15
 9b4:	89 2b       	or	r24, r25
 9b6:	21 f0       	breq	.+8      	; 0x9c0 <__stack+0xc1>
 9b8:	ce 01       	movw	r24, r28
 9ba:	0c 96       	adiw	r24, 0x0c	; 12
 9bc:	0e 94 03 01 	call	0x206	; 0x206 <uxListRemove>
 9c0:	2e 89       	ldd	r18, Y+22	; 0x16
 9c2:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxTopReadyPriority>
 9c6:	82 17       	cp	r24, r18
 9c8:	10 f4       	brcc	.+4      	; 0x9ce <__stack+0xcf>
 9ca:	20 93 f6 06 	sts	0x06F6, r18	; 0x8006f6 <uxTopReadyPriority>
 9ce:	30 e0       	ldi	r19, 0x00	; 0
 9d0:	c9 01       	movw	r24, r18
 9d2:	88 0f       	add	r24, r24
 9d4:	99 1f       	adc	r25, r25
 9d6:	88 0f       	add	r24, r24
 9d8:	99 1f       	adc	r25, r25
 9da:	88 0f       	add	r24, r24
 9dc:	99 1f       	adc	r25, r25
 9de:	82 0f       	add	r24, r18
 9e0:	93 1f       	adc	r25, r19
 9e2:	b8 01       	movw	r22, r16
 9e4:	84 5d       	subi	r24, 0xD4	; 212
 9e6:	98 4f       	sbci	r25, 0xF8	; 248
 9e8:	0e 94 b1 00 	call	0x162	; 0x162 <vListInsertEnd>
 9ec:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 9f0:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 9f4:	9e 89       	ldd	r25, Y+22	; 0x16
 9f6:	86 89       	ldd	r24, Z+22	; 0x16
 9f8:	98 17       	cp	r25, r24
 9fa:	08 f4       	brcc	.+2      	; 0x9fe <__stack+0xff>
 9fc:	b2 cf       	rjmp	.-156    	; 0x962 <__stack+0x63>
 9fe:	dc 2c       	mov	r13, r12
 a00:	b0 cf       	rjmp	.-160    	; 0x962 <__stack+0x63>
 a02:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 a06:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 a0a:	86 89       	ldd	r24, Z+22	; 0x16
 a0c:	90 e0       	ldi	r25, 0x00	; 0
 a0e:	fc 01       	movw	r30, r24
 a10:	ee 0f       	add	r30, r30
 a12:	ff 1f       	adc	r31, r31
 a14:	ee 0f       	add	r30, r30
 a16:	ff 1f       	adc	r31, r31
 a18:	ee 0f       	add	r30, r30
 a1a:	ff 1f       	adc	r31, r31
 a1c:	8e 0f       	add	r24, r30
 a1e:	9f 1f       	adc	r25, r31
 a20:	fc 01       	movw	r30, r24
 a22:	e4 5d       	subi	r30, 0xD4	; 212
 a24:	f8 4f       	sbci	r31, 0xF8	; 248
 a26:	80 81       	ld	r24, Z
 a28:	82 30       	cpi	r24, 0x02	; 2
 a2a:	48 f0       	brcs	.+18     	; 0xa3e <__stack+0x13f>
 a2c:	dd 24       	eor	r13, r13
 a2e:	d3 94       	inc	r13
 a30:	06 c0       	rjmp	.+12     	; 0xa3e <__stack+0x13f>
 a32:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <uxPendedTicks>
 a36:	8f 5f       	subi	r24, 0xFF	; 255
 a38:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <uxPendedTicks>
 a3c:	d1 2c       	mov	r13, r1
 a3e:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <xYieldPending>
 a42:	88 23       	and	r24, r24
 a44:	11 f0       	breq	.+4      	; 0xa4a <__stack+0x14b>
 a46:	dd 24       	eor	r13, r13
 a48:	d3 94       	inc	r13
 a4a:	8d 2d       	mov	r24, r13
 a4c:	df 91       	pop	r29
 a4e:	cf 91       	pop	r28
 a50:	1f 91       	pop	r17
 a52:	0f 91       	pop	r16
 a54:	ff 90       	pop	r15
 a56:	ef 90       	pop	r14
 a58:	df 90       	pop	r13
 a5a:	cf 90       	pop	r12
 a5c:	08 95       	ret

00000a5e <xTaskResumeAll>:
 a5e:	df 92       	push	r13
 a60:	ef 92       	push	r14
 a62:	ff 92       	push	r15
 a64:	0f 93       	push	r16
 a66:	1f 93       	push	r17
 a68:	cf 93       	push	r28
 a6a:	df 93       	push	r29
 a6c:	0f b6       	in	r0, 0x3f	; 63
 a6e:	f8 94       	cli
 a70:	0f 92       	push	r0
 a72:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <uxSchedulerSuspended>
 a76:	81 50       	subi	r24, 0x01	; 1
 a78:	80 93 ec 06 	sts	0x06EC, r24	; 0x8006ec <uxSchedulerSuspended>
 a7c:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <uxSchedulerSuspended>
 a80:	81 11       	cpse	r24, r1
 a82:	5f c0       	rjmp	.+190    	; 0xb42 <xTaskResumeAll+0xe4>
 a84:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxCurrentNumberOfTasks>
 a88:	81 11       	cpse	r24, r1
 a8a:	33 c0       	rjmp	.+102    	; 0xaf2 <xTaskResumeAll+0x94>
 a8c:	5d c0       	rjmp	.+186    	; 0xb48 <xTaskResumeAll+0xea>
 a8e:	d7 01       	movw	r26, r14
 a90:	15 96       	adiw	r26, 0x05	; 5
 a92:	ed 91       	ld	r30, X+
 a94:	fc 91       	ld	r31, X
 a96:	16 97       	sbiw	r26, 0x06	; 6
 a98:	c6 81       	ldd	r28, Z+6	; 0x06
 a9a:	d7 81       	ldd	r29, Z+7	; 0x07
 a9c:	ce 01       	movw	r24, r28
 a9e:	0c 96       	adiw	r24, 0x0c	; 12
 aa0:	0e 94 03 01 	call	0x206	; 0x206 <uxListRemove>
 aa4:	8e 01       	movw	r16, r28
 aa6:	0e 5f       	subi	r16, 0xFE	; 254
 aa8:	1f 4f       	sbci	r17, 0xFF	; 255
 aaa:	c8 01       	movw	r24, r16
 aac:	0e 94 03 01 	call	0x206	; 0x206 <uxListRemove>
 ab0:	2e 89       	ldd	r18, Y+22	; 0x16
 ab2:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <uxTopReadyPriority>
 ab6:	82 17       	cp	r24, r18
 ab8:	10 f4       	brcc	.+4      	; 0xabe <xTaskResumeAll+0x60>
 aba:	20 93 f6 06 	sts	0x06F6, r18	; 0x8006f6 <uxTopReadyPriority>
 abe:	30 e0       	ldi	r19, 0x00	; 0
 ac0:	c9 01       	movw	r24, r18
 ac2:	88 0f       	add	r24, r24
 ac4:	99 1f       	adc	r25, r25
 ac6:	88 0f       	add	r24, r24
 ac8:	99 1f       	adc	r25, r25
 aca:	88 0f       	add	r24, r24
 acc:	99 1f       	adc	r25, r25
 ace:	82 0f       	add	r24, r18
 ad0:	93 1f       	adc	r25, r19
 ad2:	b8 01       	movw	r22, r16
 ad4:	84 5d       	subi	r24, 0xD4	; 212
 ad6:	98 4f       	sbci	r25, 0xF8	; 248
 ad8:	0e 94 b1 00 	call	0x162	; 0x162 <vListInsertEnd>
 adc:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
 ae0:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
 ae4:	9e 89       	ldd	r25, Y+22	; 0x16
 ae6:	86 89       	ldd	r24, Z+22	; 0x16
 ae8:	98 17       	cp	r25, r24
 aea:	68 f0       	brcs	.+26     	; 0xb06 <xTaskResumeAll+0xa8>
 aec:	d0 92 f3 06 	sts	0x06F3, r13	; 0x8006f3 <xYieldPending>
 af0:	0a c0       	rjmp	.+20     	; 0xb06 <xTaskResumeAll+0xa8>
 af2:	c0 e0       	ldi	r28, 0x00	; 0
 af4:	d0 e0       	ldi	r29, 0x00	; 0
 af6:	0f 2e       	mov	r0, r31
 af8:	fd e0       	ldi	r31, 0x0D	; 13
 afa:	ef 2e       	mov	r14, r31
 afc:	f7 e0       	ldi	r31, 0x07	; 7
 afe:	ff 2e       	mov	r15, r31
 b00:	f0 2d       	mov	r31, r0
 b02:	dd 24       	eor	r13, r13
 b04:	d3 94       	inc	r13
 b06:	f7 01       	movw	r30, r14
 b08:	80 81       	ld	r24, Z
 b0a:	81 11       	cpse	r24, r1
 b0c:	c0 cf       	rjmp	.-128    	; 0xa8e <xTaskResumeAll+0x30>
 b0e:	cd 2b       	or	r28, r29
 b10:	11 f0       	breq	.+4      	; 0xb16 <xTaskResumeAll+0xb8>
 b12:	0e 94 b6 02 	call	0x56c	; 0x56c <prvResetNextTaskUnblockTime>
 b16:	c0 91 f4 06 	lds	r28, 0x06F4	; 0x8006f4 <uxPendedTicks>
 b1a:	cc 23       	and	r28, r28
 b1c:	51 f0       	breq	.+20     	; 0xb32 <xTaskResumeAll+0xd4>
 b1e:	d1 e0       	ldi	r29, 0x01	; 1
 b20:	0e 94 74 04 	call	0x8e8	; 0x8e8 <xTaskIncrementTick>
 b24:	81 11       	cpse	r24, r1
 b26:	d0 93 f3 06 	sts	0x06F3, r29	; 0x8006f3 <xYieldPending>
 b2a:	c1 50       	subi	r28, 0x01	; 1
 b2c:	c9 f7       	brne	.-14     	; 0xb20 <xTaskResumeAll+0xc2>
 b2e:	10 92 f4 06 	sts	0x06F4, r1	; 0x8006f4 <uxPendedTicks>
 b32:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <xYieldPending>
 b36:	88 23       	and	r24, r24
 b38:	31 f0       	breq	.+12     	; 0xb46 <xTaskResumeAll+0xe8>
 b3a:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortYield>
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	03 c0       	rjmp	.+6      	; 0xb48 <xTaskResumeAll+0xea>
 b42:	80 e0       	ldi	r24, 0x00	; 0
 b44:	01 c0       	rjmp	.+2      	; 0xb48 <xTaskResumeAll+0xea>
 b46:	80 e0       	ldi	r24, 0x00	; 0
 b48:	0f 90       	pop	r0
 b4a:	0f be       	out	0x3f, r0	; 63
 b4c:	df 91       	pop	r29
 b4e:	cf 91       	pop	r28
 b50:	1f 91       	pop	r17
 b52:	0f 91       	pop	r16
 b54:	ff 90       	pop	r15
 b56:	ef 90       	pop	r14
 b58:	df 90       	pop	r13
 b5a:	08 95       	ret

00000b5c <vTaskDelayUntil>:
 b5c:	0f 93       	push	r16
 b5e:	1f 93       	push	r17
 b60:	cf 93       	push	r28
 b62:	df 93       	push	r29
 b64:	8c 01       	movw	r16, r24
 b66:	eb 01       	movw	r28, r22
 b68:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vTaskSuspendAll>
 b6c:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <xTickCount>
 b70:	90 91 f8 06 	lds	r25, 0x06F8	; 0x8006f8 <xTickCount+0x1>
 b74:	f8 01       	movw	r30, r16
 b76:	40 81       	ld	r20, Z
 b78:	51 81       	ldd	r21, Z+1	; 0x01
 b7a:	9a 01       	movw	r18, r20
 b7c:	2c 0f       	add	r18, r28
 b7e:	3d 1f       	adc	r19, r29
 b80:	84 17       	cp	r24, r20
 b82:	95 07       	cpc	r25, r21
 b84:	48 f4       	brcc	.+18     	; 0xb98 <vTaskDelayUntil+0x3c>
 b86:	24 17       	cp	r18, r20
 b88:	35 07       	cpc	r19, r21
 b8a:	f8 f4       	brcc	.+62     	; 0xbca <vTaskDelayUntil+0x6e>
 b8c:	31 83       	std	Z+1, r19	; 0x01
 b8e:	20 83       	st	Z, r18
 b90:	82 17       	cp	r24, r18
 b92:	93 07       	cpc	r25, r19
 b94:	78 f4       	brcc	.+30     	; 0xbb4 <vTaskDelayUntil+0x58>
 b96:	07 c0       	rjmp	.+14     	; 0xba6 <vTaskDelayUntil+0x4a>
 b98:	24 17       	cp	r18, r20
 b9a:	35 07       	cpc	r19, r21
 b9c:	90 f0       	brcs	.+36     	; 0xbc2 <vTaskDelayUntil+0x66>
 b9e:	82 17       	cp	r24, r18
 ba0:	93 07       	cpc	r25, r19
 ba2:	78 f0       	brcs	.+30     	; 0xbc2 <vTaskDelayUntil+0x66>
 ba4:	12 c0       	rjmp	.+36     	; 0xbca <vTaskDelayUntil+0x6e>
 ba6:	60 e0       	ldi	r22, 0x00	; 0
 ba8:	a9 01       	movw	r20, r18
 baa:	48 1b       	sub	r20, r24
 bac:	59 0b       	sbc	r21, r25
 bae:	ca 01       	movw	r24, r20
 bb0:	0e 94 d5 02 	call	0x5aa	; 0x5aa <prvAddCurrentTaskToDelayedList>
 bb4:	0e 94 2f 05 	call	0xa5e	; 0xa5e <xTaskResumeAll>
 bb8:	81 11       	cpse	r24, r1
 bba:	0b c0       	rjmp	.+22     	; 0xbd2 <vTaskDelayUntil+0x76>
 bbc:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortYield>
 bc0:	08 c0       	rjmp	.+16     	; 0xbd2 <vTaskDelayUntil+0x76>
 bc2:	f8 01       	movw	r30, r16
 bc4:	31 83       	std	Z+1, r19	; 0x01
 bc6:	20 83       	st	Z, r18
 bc8:	ee cf       	rjmp	.-36     	; 0xba6 <vTaskDelayUntil+0x4a>
 bca:	f8 01       	movw	r30, r16
 bcc:	31 83       	std	Z+1, r19	; 0x01
 bce:	20 83       	st	Z, r18
 bd0:	f1 cf       	rjmp	.-30     	; 0xbb4 <vTaskDelayUntil+0x58>
 bd2:	df 91       	pop	r29
 bd4:	cf 91       	pop	r28
 bd6:	1f 91       	pop	r17
 bd8:	0f 91       	pop	r16
 bda:	08 95       	ret

00000bdc <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 bdc:	04 e0       	ldi	r16, 0x04	; 4
 bde:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 be0:	0f 2e       	mov	r0, r31
 be2:	fc e2       	ldi	r31, 0x2C	; 44
 be4:	ef 2e       	mov	r14, r31
 be6:	f7 e0       	ldi	r31, 0x07	; 7
 be8:	ff 2e       	mov	r15, r31
 bea:	f0 2d       	mov	r31, r0
 bec:	29 c0       	rjmp	.+82     	; 0xc40 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 bee:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 bf2:	d8 01       	movw	r26, r16
 bf4:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 bf6:	0e 94 2f 05 	call	0xa5e	; 0xa5e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 bfa:	cc 23       	and	r28, r28
 bfc:	09 f1       	breq	.+66     	; 0xc40 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 bfe:	0f b6       	in	r0, 0x3f	; 63
 c00:	f8 94       	cli
 c02:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 c04:	d8 01       	movw	r26, r16
 c06:	15 96       	adiw	r26, 0x05	; 5
 c08:	ed 91       	ld	r30, X+
 c0a:	fc 91       	ld	r31, X
 c0c:	16 97       	sbiw	r26, 0x06	; 6
 c0e:	c6 81       	ldd	r28, Z+6	; 0x06
 c10:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 c12:	ce 01       	movw	r24, r28
 c14:	02 96       	adiw	r24, 0x02	; 2
 c16:	0e 94 03 01 	call	0x206	; 0x206 <uxListRemove>
					--uxCurrentNumberOfTasks;
 c1a:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <uxCurrentNumberOfTasks>
 c1e:	81 50       	subi	r24, 0x01	; 1
 c20:	80 93 f9 06 	sts	0x06F9, r24	; 0x8006f9 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
 c24:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxDeletedTasksWaitingCleanUp>
 c28:	81 50       	subi	r24, 0x01	; 1
 c2a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
 c2e:	0f 90       	pop	r0
 c30:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 c32:	8f 89       	ldd	r24, Y+23	; 0x17
 c34:	98 8d       	ldd	r25, Y+24	; 0x18
 c36:	0e 94 9e 00 	call	0x13c	; 0x13c <vPortFree>
			vPortFree( pxTCB );
 c3a:	ce 01       	movw	r24, r28
 c3c:	0e 94 9e 00 	call	0x13c	; 0x13c <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 c40:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxDeletedTasksWaitingCleanUp>
 c44:	81 11       	cpse	r24, r1
 c46:	d3 cf       	rjmp	.-90     	; 0xbee <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 c48:	f7 01       	movw	r30, r14
 c4a:	80 81       	ld	r24, Z
 c4c:	82 30       	cpi	r24, 0x02	; 2
 c4e:	c0 f3       	brcs	.-16     	; 0xc40 <prvIdleTask+0x64>
			{
				taskYIELD();
 c50:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortYield>
 c54:	f5 cf       	rjmp	.-22     	; 0xc40 <prvIdleTask+0x64>

00000c56 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 c56:	80 91 ec 06 	lds	r24, 0x06EC	; 0x8006ec <uxSchedulerSuspended>
 c5a:	88 23       	and	r24, r24
 c5c:	21 f0       	breq	.+8      	; 0xc66 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 c5e:	81 e0       	ldi	r24, 0x01	; 1
 c60:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <xYieldPending>
 c64:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 c66:	10 92 f3 06 	sts	0x06F3, r1	; 0x8006f3 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 c6a:	20 91 f6 06 	lds	r18, 0x06F6	; 0x8006f6 <uxTopReadyPriority>
 c6e:	82 2f       	mov	r24, r18
 c70:	90 e0       	ldi	r25, 0x00	; 0
 c72:	fc 01       	movw	r30, r24
 c74:	ee 0f       	add	r30, r30
 c76:	ff 1f       	adc	r31, r31
 c78:	ee 0f       	add	r30, r30
 c7a:	ff 1f       	adc	r31, r31
 c7c:	ee 0f       	add	r30, r30
 c7e:	ff 1f       	adc	r31, r31
 c80:	e8 0f       	add	r30, r24
 c82:	f9 1f       	adc	r31, r25
 c84:	e4 5d       	subi	r30, 0xD4	; 212
 c86:	f8 4f       	sbci	r31, 0xF8	; 248
 c88:	30 81       	ld	r19, Z
 c8a:	31 11       	cpse	r19, r1
 c8c:	11 c0       	rjmp	.+34     	; 0xcb0 <vTaskSwitchContext+0x5a>
 c8e:	21 50       	subi	r18, 0x01	; 1
 c90:	82 2f       	mov	r24, r18
 c92:	90 e0       	ldi	r25, 0x00	; 0
 c94:	fc 01       	movw	r30, r24
 c96:	ee 0f       	add	r30, r30
 c98:	ff 1f       	adc	r31, r31
 c9a:	ee 0f       	add	r30, r30
 c9c:	ff 1f       	adc	r31, r31
 c9e:	ee 0f       	add	r30, r30
 ca0:	ff 1f       	adc	r31, r31
 ca2:	e8 0f       	add	r30, r24
 ca4:	f9 1f       	adc	r31, r25
 ca6:	e4 5d       	subi	r30, 0xD4	; 212
 ca8:	f8 4f       	sbci	r31, 0xF8	; 248
 caa:	30 81       	ld	r19, Z
 cac:	33 23       	and	r19, r19
 cae:	79 f3       	breq	.-34     	; 0xc8e <vTaskSwitchContext+0x38>
 cb0:	ac 01       	movw	r20, r24
 cb2:	44 0f       	add	r20, r20
 cb4:	55 1f       	adc	r21, r21
 cb6:	44 0f       	add	r20, r20
 cb8:	55 1f       	adc	r21, r21
 cba:	44 0f       	add	r20, r20
 cbc:	55 1f       	adc	r21, r21
 cbe:	48 0f       	add	r20, r24
 cc0:	59 1f       	adc	r21, r25
 cc2:	da 01       	movw	r26, r20
 cc4:	a4 5d       	subi	r26, 0xD4	; 212
 cc6:	b8 4f       	sbci	r27, 0xF8	; 248
 cc8:	11 96       	adiw	r26, 0x01	; 1
 cca:	ed 91       	ld	r30, X+
 ccc:	fc 91       	ld	r31, X
 cce:	12 97       	sbiw	r26, 0x02	; 2
 cd0:	02 80       	ldd	r0, Z+2	; 0x02
 cd2:	f3 81       	ldd	r31, Z+3	; 0x03
 cd4:	e0 2d       	mov	r30, r0
 cd6:	12 96       	adiw	r26, 0x02	; 2
 cd8:	fc 93       	st	X, r31
 cda:	ee 93       	st	-X, r30
 cdc:	11 97       	sbiw	r26, 0x01	; 1
 cde:	41 5d       	subi	r20, 0xD1	; 209
 ce0:	58 4f       	sbci	r21, 0xF8	; 248
 ce2:	e4 17       	cp	r30, r20
 ce4:	f5 07       	cpc	r31, r21
 ce6:	29 f4       	brne	.+10     	; 0xcf2 <vTaskSwitchContext+0x9c>
 ce8:	42 81       	ldd	r20, Z+2	; 0x02
 cea:	53 81       	ldd	r21, Z+3	; 0x03
 cec:	fd 01       	movw	r30, r26
 cee:	52 83       	std	Z+2, r21	; 0x02
 cf0:	41 83       	std	Z+1, r20	; 0x01
 cf2:	fc 01       	movw	r30, r24
 cf4:	ee 0f       	add	r30, r30
 cf6:	ff 1f       	adc	r31, r31
 cf8:	ee 0f       	add	r30, r30
 cfa:	ff 1f       	adc	r31, r31
 cfc:	ee 0f       	add	r30, r30
 cfe:	ff 1f       	adc	r31, r31
 d00:	8e 0f       	add	r24, r30
 d02:	9f 1f       	adc	r25, r31
 d04:	fc 01       	movw	r30, r24
 d06:	e4 5d       	subi	r30, 0xD4	; 212
 d08:	f8 4f       	sbci	r31, 0xF8	; 248
 d0a:	01 80       	ldd	r0, Z+1	; 0x01
 d0c:	f2 81       	ldd	r31, Z+2	; 0x02
 d0e:	e0 2d       	mov	r30, r0
 d10:	86 81       	ldd	r24, Z+6	; 0x06
 d12:	97 81       	ldd	r25, Z+7	; 0x07
 d14:	90 93 51 07 	sts	0x0751, r25	; 0x800751 <pxCurrentTCB+0x1>
 d18:	80 93 50 07 	sts	0x0750, r24	; 0x800750 <pxCurrentTCB>
 d1c:	20 93 f6 06 	sts	0x06F6, r18	; 0x8006f6 <uxTopReadyPriority>
 d20:	08 95       	ret

00000d22 <_exit>:
 d22:	f8 94       	cli

00000d24 <__stop_program>:
 d24:	ff cf       	rjmp	.-2      	; 0xd24 <__stop_program>
